<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
    <title>The XSPF Playlist Format, version 0</title>
    <style type="text/css">
      /*<![CDATA[*/

body {
font-family:    Verdana, Myriad Web, Syntax, sans-serif;
font-size: 80%; 
color: #555753; 

}

blockquote {
font-style: italic;
}

a {
display: inline;
}

pre {  
margin-left: 3em; 
background-color: lightyellow;
}

h1 {
text-align: center;
}

pre {
background-color: lightyellow;
font-family: courier, monospace;
white-space: pre;
color: #993300;
}

pre:before {
content: "EXAMPLE: ";
}

.attributes:before {
content: "ATTRIBUTES: ";
}

.elements:before {
content: "ELEMENTS: ";
}


        /*]]>*/
    </style>
  </head>
  <body>

    <h1>The XSPF Playlist Format, version 0</h1>

<a name="WhatisXSPF"/><h2>What is XSPF?</h2>

    <p>There is no XML format for playlists that can measure up to the
	  standards of the formats for web pages (HTML), weblogs (RSS),
	  and web graphs (RDF/XML). It is evident that there is a need,
	  because XML is the preferred data description language of the
	  moment and as a result the tools and skills to use it are
	  ubiquitous.</p>

	<p>It is also evident that existing playlist formats fall short.
	  ASX (for Windows Media Player) and the iTunes library format are
	  proprietary.  ASX resembles XML in that it uses angle brackets,
	  but is not XML by any means.  M3U, RAM, and M4U are flat files;
	  QuickTime is binary; Pls is in the Windows .ini format;
	  Gnomoradio RDF is RDF, not XML.  SMIL is too hard to implement.
	  The timing model of RSS doesn't fit audio and video.  Forcing
	  timing models into HTML, as HTML+Time does, creates an
	  unintelligible feature set.  Few of these formats are well
	  documented.  None of these formats make simple features easy to
	  code and hard features possible.  Only one is an open standard.
	  Not a single one offers interoperability across major vendors.
	  Not a single one attempts to solve these problems.</p>

	<p>The pressing question for software developers is <em>why should
		I support this XML playlist format</em> instead of or in
		addition to ASX, SMIL, Gnomoradio RDF, iTunes XML, or RSS?
		Why does the world need yet another XML playlist format?  The
		answer is <em>XSPF is by far the most carefully crafted XML
		playlist format</em>.</p>

<a name="Example"/><h2>Example</h2>
    A very simple document looks like this: 
    <pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;playlist version="0" xmlns = "http://xspf.org/ns/0/"&gt;
  &lt;trackList&gt;
    &lt;track&gt;&lt;location&gt;file:///mp3s/Yo%20La%20Tengo/1_Nuclear%20War%20Version%201.mp3&lt;/location&gt;&lt;/track&gt;
    &lt;track&gt;&lt;location&gt;file:///mp3s/Yo%20La%20Tengo/2_Nuclear%20War%20Version%202.mp3&lt;/location&gt;&lt;/track&gt;
    &lt;track&gt;&lt;location&gt;file:///mp3s/Yo%20La%20Tengo/3_Nuclear%20War%20Version%203.mp3&lt;/location&gt;&lt;/track&gt;
    &lt;track&gt;&lt;location&gt;file:///mp3s/Yo%20La%20Tengo/4_Nuclear%20War%20Version%204&lt;/location&gt;&lt;/track&gt;
    &lt;track&gt;&lt;location&gt;file:///mp3s/Yo%20La%20Tengo/5_Nuclear%20War%20Version%204%20(Mike%20Ladd%20Remix).mp3&lt;/location&gt;&lt;/track&gt;
  &lt;/trackList&gt;
&lt;/playlist&gt;</pre>

or this:
    <pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;playlist version="0" xmlns = "http://xspf.org/ns/0/"&gt;
  &lt;trackList&gt;
    &lt;track&gt;&lt;location&gt;http://yolatengo.com/1_Nuclear%20War%20Version%201.mp3&lt;/location&gt;&lt;/track&gt;
    &lt;track&gt;&lt;location&gt;http://yolatengo.com/2_Nuclear%20War%20Version%202.mp3&lt;/location&gt;&lt;/track&gt;
    &lt;track&gt;&lt;location&gt;http://yolatengo.com/3_Nuclear%20War%20Version%203.mp3&lt;/location&gt;&lt;/track&gt;
    &lt;track&gt;&lt;location&gt;http://yolatengo.com/4_Nuclear%20War%20Version%204&lt;/location&gt;&lt;/track&gt;
    &lt;track&gt;&lt;location&gt;http://yolatengo.com/5_Nuclear%20War%20Version%204%20(Mike%20Ladd%20Remix).mp3&lt;/location&gt;&lt;/track&gt;
  &lt;/trackList&gt;
&lt;/playlist&gt;</pre>


    <a name="toc"/>	  <h2>Table of Contents</h2>
	  <ol>
<li><a href="#WhatisXSPF">What is XSPF?</a></li>
<li><a href="#Example">Example</a></li>
<li><a href="#Administrativenotes">Administrative notes</a></li>
<li><a href="#Abstractions">Abstractions</a></li>
<li ><ol>
<li><a href="#Definingplaylists">Defining playlists</a></li>
<li><a href="#Whataplaylistisnot">What a playlist is not</a></li>
<li><a href="#Shareability">Shareability</a></li>
</ol></li>
<li><a href="#Elementdefinitions">Element definitions</a></li>
<li ><ol>
<li><a href="#xml">xml</a></li>
<li class="attributes"><ol>
<li><a href="#version">version</a></li>
<li><a href="#encoding">encoding</a></li>
</ol></li>
<li class="elements"><ol>
<li><a href="#playlist">playlist</a></li>
<li class="attributes"><ol>
<li><a href="#xmlns">xmlns</a></li>
<li><a href="#version">version</a></li>
</ol></li>
<li class="elements"><ol>
<li><a href="#title">title</a></li>
<li><a href="#annotation">annotation</a></li>
<li><a href="#creator">creator</a></li>
<li><a href="#info">info</a></li>
<li><a href="#location">location</a></li>
<li><a href="#identifier">identifier</a></li>
<li><a href="#image">image</a></li>
<li><a href="#date">date</a></li>
<li><a href="#license">license</a></li>
<li><a href="#attribution">attribution</a></li>
<li><a href="#link">link</a></li>
<li class="attributes"><ol>
<li><a href="#rel">rel</a></li>
</ol></li>
<li><a href="#meta">meta</a></li>
<li class="attributes"><ol>
<li><a href="#rel">rel</a></li>
</ol></li>
<li><a href="#trackList">trackList</a></li>
<li class="elements"><ol>
<li><a href="#track">track</a></li>
<li class="elements"><ol>
<li><a href="#location">location</a></li>
<li><a href="#identifier">identifier</a></li>
<li><a href="#title">title</a></li>
<li><a href="#annotation">annotation</a></li>
<li><a href="#creator">creator</a></li>
<li><a href="#info">info</a></li>
<li><a href="#image">image</a></li>
<li><a href="#album">album</a></li>
<li><a href="#trackNum">trackNum</a></li>
<li><a href="#duration">duration</a></li>
<li><a href="#link">link</a></li>
<li class="attributes"><ol>
<li><a href="#rel">rel</a></li>
</ol></li>
<li><a href="#meta">meta</a></li>
<li class="attributes"><ol>
<li><a href="#rel">rel</a></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
<li><a href="#Designandarchitecture">Design and architecture</a></li>
<li ><ol>
<li><a href="#Contentresolver">Content resolver</a></li>
<li><a href="#Fuzzynames">Fuzzy names</a></li>
</ol></li>
<li><a href="#RequirementsforXSPFplayers">Requirements for XSPF players</a></li>
<li ><ol>
<li><a href="#Gracefulfailure">Graceful failure</a></li>
<li><a href="#Relativepaths">Relative paths</a></li>
</ol></li>
<li><a href="#Usecasesforplaylists">Usecases for playlists</a></li>
<li ><ol>
<li><a href="#Flagplayerapplication">Flag player application</a></li>
<li><a href="#Allowstreaming">Allow streaming</a></li>
<li><a href="#Collectingfragmentedresources">Collecting fragmented resources</a></li>
<li><a href="#Alternatemediatypes">Alternate media types</a></li>
<li><a href="#Cachingderivedinfo">Caching derived info</a></li>
<li><a href="#Metadatastorage">Metadata storage</a></li>
<li><a href="#Authoringcompilationsforexpressivereasons">Authoring compilations for expressive reasons</a></li>
</ol></li>
<li><a href="#Recipes">Recipes</a></li>
<li ><ol>
<li><a href="#HowdoIsetrelativepathsinanXSPFplaylistforexampleifIwanttouseitasafilemanifest">How do I set relative paths in an XSPF playlist, for example if I want to use it as a file manifest?</a></li>
<li><a href="#HowtoIconvertXSPFtoM3U">How to I convert XSPF to M3U?</a></li>
<li><a href="#HowtoIconvertXSPFtoHTML">How to I convert XSPF to HTML?</a></li>
<li><a href="#HowtoIconvertXSPFtoSMIL">How to I convert XSPF to SMIL?</a></li>
<li><a href="#HowtoIconvertXSPFtoSoundblox">How to I convert XSPF to Soundblox?</a></li>
<li><a href="#HowdoIcustomizeXSPFShouldIusenamespaces">How do I customize XSPF?  Should I use namespaces?</a></li>
<li><a href="#HowdoIvalidateXSPF">How do I validate XSPF?</a></li>
<li><a href="#HowdoIuseMusicBrainzmetadata">How do I use MusicBrainz metadata?</a></li>
<li><a href="#HowdoIrefertoaBitTorrent">How do I refer to a BitTorrent?</a></li>
<li><a href="#HowdoIrefertoaMagnetorsha1URI">How do I refer to a Magnet or sha1: URI?</a></li>
</ol></li>
<li><a href="#Administrative">Administrative</a></li>
<li ><ol>
<li><a href="#Validate">Validate</a></li>
</ol></li>

	  </ol>



<a name="Administrativenotes"/><h2>Administrative notes</h2>

	<p>Version 0 is frozen and complete.  Anybody writing code
	according to this specification can be very confident that it will
	not change.</p>

    <p>The home of our working group is <a
	  href="http://xspf.org">http://xspf.org</a>.  Members include
	  Dave Brown and Ian Rogers of Yahoo; Dan Brickley from the W3C;
	  Kevin Marks of Technorati; Matthias Freidrich and Robert Kaye of
	  MusicBrainz; Ryan Shaw of UC Berkely; and myself, from Webjay.</p>

    <p>This author of this document is <a
       href="http://gonze.com">Lucas Gonze</a>. Our group started work
       in the winter of 2004.  The first public draft of this document
       was May 9, 2004, the most recent was January 6, 2005.</p>

	<p>In a few places in this document I will use the term MUST in
	   all caps, which will remind some readers of formal standards.
	   In this document the term should be interpreted to mean that
	   something shouted is important.  XSPF is not a standard, it is
	   an ad-hoc project by a group of individuals.</p>

<a name="Abstractions"/><h2>Abstractions</h2>

	<dl>
	  
	  <dt><a name="Definingplaylists"/>Defining playlists</dt><!-- first child of abstractions -->
	  <dd>
		<p>An XSPF playlist describes a sequence of objects to
		  be rendered.  Objects might be audio, video, text,
		  playlists, or any other media type.  The function of a
		  playlist is to identify the objects and communicate
		  their order.</p>
	  </dd><!-- first child of abstractions -->

	  <dt><a name="Whataplaylistisnot"/>What a playlist is not</dt><!-- first child of abstractions -->
	  <dd>
		<p>The function of a playlist <em>is not</em> to
		  communicate metadata about the composer, song title,
		  etc.  Metadata is hard and there are many providers
		  already.  We decided that we couldn't compete, and
		  that there was no need for us to try.  Moreover, good
		  metadata does not travel well -- every user has to
		  recreate it.  Metadata should come from external
		  sources and namespaces like MusicBrainz or Gracenote;
		  this what the XSPF <span class="elem">link</span>
		  and <span class="elem">meta</span> elements are
		  for.</p>

		<p>The function of a playlist <em>is not</em> to store
		  derived information about objects that a user has a
		  copy of.  A playlist is not a catalog.  A catalog is
		  computed across hard data like files; it stores
		  information like filesystem paths and the contents of
		  ID3 tags.  This data has no value on any machine but
		  the one on which it originated.  Sharing this data
		  would be a privacy and security violation.  Software
		  which needs access to this data has no reason to
		  maintain it in a standard format, because it has no
		  reason to allow access to it.  Standardizing this data
		  would be fruitless, because there are an endless
		  number of measurements that software might take and
		  store.  Derived information belongs in
		  a <em>catalog</em>.</p>

		<p>Things a playlist is not, then, are a metadata format or a
		  catalog.  We took care to enable these features, but also to
		  avoid duplicating their functionality, poorly.</p>

	  </dd><!-- first child of abstractions -->

	  <dt><a name="Shareability"/>Shareability</dt><!-- first child of abstractions -->
	  <dd>

		<p>If there is no reason for a playlist to be shared, there is
		  no need for a new format.  Even a buggy format does no
		  damage if it is created and consumed by the same software on
		  the same machine.  The need for a new format only comes up
		  when a playlist travels from one machine to another, for
		  example when it is published on the internet.</p>

		<p>One type of shareability is between different pieces of
		software on the same machine.  It is common for playlists
		created with one application to not be usable by another
		application on the same machine because of different or
		conflicting interpretations of the playlist format.  M3U
		suffers from this very badly, because M3U playlists often
		reference files according to a base path which changes from
		application to application.  The XSPF group aimed to fix this
		by providing unambiguous definitions.</p>

		<p>The other type of shareability is between different
		machines.  For playlists to be meaningful on different
		machines, they must be able to identify network resources.
		Audio and video objects are often abstractions like "movie X
		by director Y" rather than computer-friendly objects like
		"whatever file can be gotten from the URL http://foo/x/y".  To
		handle this problem, we have provided support for media
		objects to be found via queries; XSPF identifiers
		are <em>fuzzy names</em>.</p>

	  </dd><!-- first child of abstractions -->

	</dl><!-- end abstractions -->

<a name="Elementdefinitions"/><h2>Element definitions</h2>
    <dl>
      <dt><a name="xml"/>xml</dt>
      <dd>
        <dl class="attributes">
          <dt><a name="version"/>version</dt>
          <dd>1.0</dd>
          <dt><a name="encoding"/>encoding</dt>
          <dd>utf-8 recommended to allow unicode characters in text fields</dd>
        </dl>
        <dl class="elements">
          <dt><a name="playlist"/>playlist</dt>
          <dd>
            <dl class="attributes">
              <dt><a name="xmlns"/>xmlns</dt>
              <dd>http://xspf.org/ns/0/</dd>
              <dt><a name="version"/>version</dt>
              <dd>0</dd>
            </dl>
            <dl class="elements">
              <dt><a name="title"/>title</dt>
              <dd>A human-readable title for the playlist. xspf:playlist elements MAY
				contain exactly one.</dd>
              <dt><a name="annotation"/>annotation</dt>
              <dd>A human-readable comment on the playlist in text/plain format.
				xspf:playlist elements MAY contain exactly one.</dd>
              <dt><a name="creator"/>creator</dt>
              <dd>Human-readable name of the entity (author, authors, group, company,
				etc) that authored the playlist. xspf:playlist elements MAY contain exactly
				one.</dd>
              <dt><a name="info"/>info</dt>
              <dd>URI of a web page to find out more about this playlist. Likely to be
				homepage of the author, and would be used to find out more about the author
				and to find more playlists by the author. xspf:playlist elements MAY
				contain exactly one.</dd>
              <dt><a name="location"/>location</dt>
              <dd>Source URI for this playlist. xspf:playlist elements MAY contain zero
				or more location elements.</dd>
              <dt><a name="identifier"/>identifier</dt>
              <dd>Canonical ID for this playlist. Likely to be a hash or other
				location-independent name. MUST be a legal URI. xspf:playlist elements MAY
				contain zero or more identifier elements.</dd>
              <dt><a name="image"/>image</dt>
              <dd>URI of an image to display in the absence of a
				//playlist/trackList/image element. xspf:playlist elements MAY contain
				exactly one.</dd>
              <dt><a name="date"/>date</dt>
              <dd>ISO8601 creation date (not last-modified date) of the playlist.
				xspf:playlist elements MAY contain exactly one.</dd>
              <dt><a name="license"/>license</dt>
              <dd>URI of a resource that describes the license under
				which this playlist was released.  xspf:playlist
				elements may contain zero or one license element.</dd>
              <dt><a name="attribution"/>attribution</dt>
              <dd>
                <p>An ordered list of URIs. The purpose is to satisfy licenses allowing
                  modification but requiring attribution. If you modify such a playlist,
                  move its //playlist/location element or //playlist/identifier
                  to the top of the items in the //playlist/attribution element.
                  xspf:playlist elements MAY contain exactly one xspf:attribution
                  element.</p>
                <pre>
&lt;attribution&gt;
  &lt;location&gt;http://snafu.com/modified_version_of_modified_version_of_original_playlist.xspf&lt;/location&gt;
  &lt;location&gt;http://bar.com/modified_version_of_original_playlist.xspf&lt;/location&gt;
  &lt;location&gt;http://foo.com/original_playlist.xspf&lt;/location&gt;
 &lt;/attribution&gt;</pre>
              </dd>

              <dt><a name="link"/>link</dt>
              <dd>
                <p>The link element allows non-XSPF web resources to be included in XSPF
                  documents without breaking XSPF validation.  xspf:playlist elements MAY
				contain zero or more link elements.</p>
                <pre>&lt;link rel="http://foaf.org/namespace/version1"&gt;http://socialnetwork.org/foaf/mary.rdfs&lt;/link&gt;</pre>
                <dl class="attributes">
                  <dt><a name="rel"/>rel</dt>
                  <dd>URI of a resource type.</dd>
                </dl>
                <p>URI of a resource.</p>
              </dd>
              <dt><a name="meta"/>meta</dt>
              <dd>
                <p>The meta element allows non-XSPF metadata to be included in XSPF
                  documents without breaking XSPF validation.  xspf:playlist elements MAY
				contain zero or more meta elements.</p>
                <pre>&lt;meta rel="http://example.org/key"&gt;value&lt;/meta&gt;</pre>
                <dl class="attributes">
                  <dt><a name="rel"/>rel</dt>
                  <dd>URI of a resource defining the metadata.</dd>
                </dl>
                <p>Value of the metadata element. MUST be valid text/plain, not
				  XML.</p>
              </dd>
              <dt><a name="trackList"/>trackList</dt>
              <dd>
                <p>Ordered list of xspf:track elements to be rendered.
                The sequence is a hint, not a requirement; renderers
                are advised to play tracks from top to bottom unless
                there is an indication otherwise.<p/>

				  <p>If an xspf:track element cannot be rendered, a
                  user-agent MUST skip to the next xspf:track element
                  and MUST NOT interrupt the sequence.</p>

				  <p>xspf:playlist elements MUST contain one and only
                  one trackList element.</p>
                <dl class="elements">
                  <dt><a name="track"/>track</dt>
                  <dd>
                    <dl class="elements">
                      <dt><a name="location"/>location</dt>
                      <dd>URI of resource to be rendered. Probably an audio resource, but
						MAY be any type of resource with a well-known duration, such as
						video, a SMIL document, or an XSPF document. The duration of the
						resource defined in this element defines the duration of rendering.
						xspf:track elements MAY contain zero or more
						location elements, but a user-agent MUST NOT render more than one
						of the named resources.</dd>
                      <dt><a name="identifier"/>identifier</dt>
                      <dd>Canonical ID for this resource. Likely to be
						a hash or other location-independent name,
						such as a MusicBrainz identifier or isbn URN
						(if there existed isbn numbers for audio).
						MUST be a legal URI. xspf:playlist elements
						MAY contain zero or more identifier
						elements.</dd>
                      <dt><a name="title"/>title</dt>
                      <dd>Human-readable name of the track that authored the resource
						which defines the duration of track rendering. This value is
						primarily for fuzzy lookups, though a user-agent may display it.
						xspf:track elements MAY contain exactly
						one.</dd>
                      <dt><a name="annotation"/>annotation</dt>
                      <dd>A human-readable comment on the track in text/plain format.
						xspf:track elements MAY contain exactly
						one.</dd>
                      <dt><a name="creator"/>creator</dt>
                      <dd>Human-readable name of the entity (author, authors, group,
						company, etc) that authored the resource which defines the duration
						of track rendering. This value is primarily for fuzzy lookups,
						though a user-agent may display it. xspf:track
						elements MAY contain exactly one.</dd>
                      <dt><a name="info"/>info</dt>
                      <dd>URI of a place where this resource can be bought or more info
						can be found.</dd>
                      <dt><a name="image"/>image</dt>
                      <dd>URI of an image to display for the duration of the track.
						xspf:track elements MAY contain exactly
						one.</dd>
                      <dt><a name="album"/>album</dt>
                      <dd>Human-readable name of the collection from which the resource
						which defines the duration of track rendering comes. For a song
						originally published as a part of a CD or LP, this would be the
						title of the original release. This value is primarily for fuzzy
						lookups, though a user-agent may display it.
						xspf:track elements MAY contain exactly
						one.</dd>
                      <dt><a name="trackNum"/>trackNum</dt>
                      <dd>Integer with value greater than zero giving the ordinal
						position of the media on the xspf:album. This value is primarily
						for fuzzy lookups, though a user-agent may display it.
						xspf:track elements MAY contain exactly
						one.   It MUST be a valid <a href="http://www.w3.org/TR/xmlschema-2/#dt-nonNegativeInteger">XML Schema nonNegativeInteger</a>.</dd>

                      <dt><a name="duration"/>duration</dt>

					  <dd>The time to render a resource, in
						milliseconds.  It MUST be a valid <a
						href="http://www.w3.org/TR/xmlschema-2/#dt-nonNegativeInteger">XML
						Schema nonNegativeInteger</a>.  This value is
						only a hint -- different XSPF generators will
						generate slightly different values. A
						user-agent MUST NOT use this value to
						determine the rendering duration, since the
						data will likely be low quality.  xspf:track
						elements MAY contain exactly one duration
						element.</dd>
					  <dt><a name="link"/>link</dt>
					  <dd>
						<p>The link element allows non-XSPF web
						  resources to be included in
						  xspf:track elements
						  without breaking XSPF validation.</p>
						<pre>&lt;link rel="http://foaf.org/namespace/version1"&gt;http://socialnetwork.org/foaf/mary.rdfs&lt;/link&gt;</pre>
						<dl class="attributes">
						  <dt><a name="rel"/>rel</dt>
						  <dd>URI of a resource type.</dd>
						</dl>
						<p>URI of a resource.</p>
					  </dd>
					  <dt><a name="meta"/>meta</dt>
					  <dd>
						<p>The meta element allows non-XSPF metadata
						  to be included in
						  xspf:track elements
						  without breaking XSPF validation.</p>
						<pre>&lt;meta rel="http://example.org/key"&gt;value&lt;/meta&gt;</pre>
						<dl class="attributes">
						  <dt><a name="rel"/>rel</dt>
						  <dd>URI of a resource defining the metadata.</dd>
						</dl>
						<p>Value of the metadata element. MUST be valid text/plain, not
						  XML.</p>
					  </dd>
                    </dl>
                  </dd>
                </dl>
              </dd>
            </dl>
          </dd>
        </dl>
      </dd>
    </dl>

<a name="Designandarchitecture"/><h2>Design and architecture</h2>

	<dl>

	  <dt><a name="Contentresolver"/>Content resolver</dt>

	  <dd>

		<p>On a surface level you can use XSPF like any other playlist
		  format.  Drop a bunch of filenames into an XSPF document, prepend
		  "file://" to each, and you're ready to go.  Under the surface
		  there is much more.</p>
		
		<p>The guiding design principle was to separate the functionality
		  of a catalog of files from the functionality of a list of songs.
		  Most MP3 players have some sort of cache for file information.
		  This cache stores a list, or catalog, of available files and
		  metadata from ID3 tags and other sources.  XSPF is not a catalog
		  format.  XSPF exists only to say which songs to play.  Almost
		  everything in XSPF is for the purpose of answering the
		  question <em>which resource</em>, rather than the
		  question <em>what is this resource</em>.</p>
		
		<p>If XSPF is not a catalog format, what is it?  XSPF is an
		  intermediate format.  We expected a new kind of software called
		  a <em>content resolver</em> to do the job of converting XSPF to a
		  plain old list of files or URLs.  A content resolver would be
		  smart enough to keep your playlists from breaking when you move
		  your MP3s from /mp3s to /music/mp3.  It would be able to figure
		  out that a playlist entry by the artist "Hank Williams" with the
		  title "Your Cheating Heart" could be satisfied by the file
		  /mp3s/hankwilliams/yourcheatingheart.mp3.  It might even know how
		  to query the iTunes music store or another online provider to
		  locate and download a missing song.</p>
		
		<p>The content resolver maintains the catalog of your songs in
		  whatever format it prefers.  It might use a flatfile, a file in
		  the Berkeley DB format, or a SQL database.  It might use only ID3
		  metadata, but it might also know how to query MusicBrainz or
		  another metadata service.</p>
	  </dd>

	  <dt><a name="Fuzzynames"/>Fuzzy names</dt>
	  <dd>Any given track can be identified in a number of ways.  We
	  provided means for absolute identifiers like URLs, filesystem
	  paths and secure hashes, but also for query-based identifiers -- 
	  free text fields like artist and work title and numeric fields
	  for song length, all of which together should be enough for a
	  good content resolver to turn into files.
	  </dd>

	</dl>

<a name="RequirementsforXSPFplayers"/><h2>Requirements for XSPF players</h2>
	<dl><!-- begin requirements -->
	  <dt><a name="Gracefulfailure"/>Graceful failure</dt><!-- first child of normative -->
	  <dd>
		<p>If a media player is unable to render a resource, the show
		MUST go on.  Playlists exist in time; a player that stops
		processing when it encounters an error is considered broken;
		it is not conformant with the standard; it must be shunned by
		the community and made an outcast.  Players will frequently
		encounter resources that they cannot render -- this is not a
		fatal error unless the player stops processing the
		playlist.</p>
		<p></p>
	  </dd>
	  
	  <dt><a name="Relativepaths"/>Relative paths</dt><!-- first child of normative -->
	  <dd>
		<p>Relative paths MUST be resolved according to the <a
		href="http://www.w3.org/TR/xmlbase/">XML Base</a>
		specification or <a
		href="http://www.w3.org/TR/xmlbase/#RFC2396">IETF RFC
		2396</a>:</p>

		<blockquote>The rules for determining the base URI can be 
			summarized as follows (highest priority to lowest):
			<ol>
			  <li>The base URI is embedded in the document's content.</li>
			  <li>The base URI is that of the encapsulating entity (message, 
				document, or none).</li>

			  <li>The base URI is the URI used to retrieve the entity.</li>
			  <li>The base URI is defined by the context of the application.</li>
			</ol>
		</blockquote>
	  </dd>
	  
	</dl><!-- end requirements -->

<a name="Usecasesforplaylists"/><h2>Usecases for playlists</h2>

	<dl>

	  <dt><a name="Flagplayerapplication"/>Flag player application</dt><!-- first child of usecases -->
	  <dd>

		<p>Scenario: A user clicks on a link to an audio or
		  video object in their browser.  The browser needs to
		  hand the object off to a helper application like an
		  MP3 player.  If there is an intermediate playlist
		  object between the browser and helper application, and
		  the browser needs to ensure that the right helper is
		  launched, the playlist needs to be of a type which is
		  mapped to the same helper application.</p>

		<p>Typical solution: Use a dedicated playlist format
		  for almost every media subtype.  For Real audio there
		  is RAM; for MP4 video there is M4U; for MP3 there is
		  M3U; even though RAM, M4U and M3U are almost identical
		  in syntax.  The QuickTime format is able to avoid this
		  problem only because the container format and media
		  format are integrated -- a QuickTime file is both a
		  playlist and a media object.</p>

		<p>XSPF' solution: The XSPF format does not yet have a
		  solution to this problem, because the working group
		  has not yet tackled it.  (Though I can speculate that
		  a content resolver in between the browser and helper
		  application would have the means to do it).</p>

	  </dd><!-- first child of usecases -->

	  <dt><a name="Allowstreaming"/>Allow streaming</dt><!-- first child of usecases -->
	  <dd>

		<p>Scenario: A user clicks on an audio or video link.
		  Before handing off control to the helper application,
		  the browser must download whatever the link points to.
		  For streaming media this makes no sense; either the
		  download will never finish or waiting for a complete
		  download defeats the purpose.</p>

		<p>Typical solution: rather than linking to an audio
		  or video document, link to a playlist containing a URL
		  of an audio or video document.  Playlists used for
		  this purpose often contain only a single URL.  The Pls
		  format, which is used for MP3-based webcasting, and
		  which contains a single URL of a never-ending stream,
		  takes this approach.</p>

		<p>XSPF' solution: any reasonably compact playlist
		  format supports this equally well.  This rules out
		  iTunes library format and sometimes QuickTime, but
		  allows XSPF along with M3U, Pls and other relatively
		  terse formats.</p>

	  </dd><!-- first child of usecases -->

	  <dt><a name="Collectingfragmentedresources"/>Collecting fragmented resources</dt><!-- first child of usecases -->
	  <dd>

		<p>Scenario: There is a very large object like a DVD
		  rip.  The likelyhood of downloading the entire object
		  in one shot is low, so the object has been split into
		  pieces.  The object then needs to be reassembled on
		  the client side.</p>

		<p>Typical solution: Create a zip file or tarball,
		  which use checksums to ensure integrity of the
		  download; start by sending a playlist which acts a
		  file manifest and allows a user agent to download
		  sub-objects in digestible chunks.  However, a manifest
		  has to express paths to related objects according to a
		  filesystem which does not exist on the client, there
		  has to be agreement between the client and server on
		  how to interpret relative paths in a playlist.  The
		  problem is that few playlist formats -- only SMIL, to
		  my knowledge -- define the meaning of relative paths
		  in a playlist.</p>

		<p>XSPF' solution: XSPF clearly defines the meaning of
		  relative paths according to the rule that a client
		  must interpret relative paths in a playlist according
		  to the XML Base specification or IETF RFC 2396.</p>

	  </dd><!-- first child of usecases -->

	  <dt><a name="Alternatemediatypes"/>Alternate media types</dt><!-- first child of usecases -->
	  <dd>

		<p>Scenario: There is a renderer which is capable of
		  rendering one form of a media object but not another.
		  The server is able to deliver the object in either
		  format, but it needs to communicate URLs for both.
		  Though HTTP content negotiation can be used for
		  instances where the renderer contacts the server
		  directly, it doesn't support protocol negotiation, and
		  it can't be used in non-HTTP protocols.</p>

		<p>Typical solution: This is particularly a problem
		  for Real, which has a large installed base of obsolete
		  software to be babied.  The solution is to delver
		  alternate URLs within the same playlist and allow the
		  client to choose.  The RAM format allows both a pnm:
		  and a rtsp: URI within the same playlist, separated by
		  a line containg the keyword "--stop--".</p>

		<p>XSPF' solution: An XSPF track object can contain
		  multiple identifiers or locations for the same media
		  object.</p>
	  </dd><!-- first child of usecases -->

	  <dt><a name="Cachingderivedinfo"/>Caching derived info</dt><!-- first child of usecases -->
	  <dd>
		<p>Scenario: An MP3 player needs to access information
		  about media objects which is too expensive to compute
		  in real time.  For a large number of file a user can't
		  wait to re-read ID3 tags, computing SHA1 hashes, or
		  perform a fourier transform for each.</p>
		<p>Typical solution: An MP3 player computes the
		  information once, the first time it encounters an
		  object, then caches the data.  The iTunes library
		  format stores computed information like ID3 data in
		  the global catalog and playlist.</p>
		<p>XSPF' solution: XSPF defers this information to an
		  external module called the content resolver, and
		  mandates that the information not be included in
		  shared playlists.</p>
	  </dd><!-- first child of usecases -->

	  <dt><a name="Metadatastorage"/>Metadata storage</dt><!-- first child of usecases -->
	  <dd>
		<p>Scenario: A user needs information about high level
		  concepts like artist and song title rather than
		  machine-level concepts like file name and bit rate.
		  How should artist and song title be communicated, and
		  how should they be stored?</p>
		<p>Typical solution: Derive the metadata according to
		  an application-defined process like extracting ID3
		  tags, then then store a copy of the metadata in any
		  playlists that reference a media object.  The EXTINF
		  property of the extended M3U format is used in this
		  way.</p>
		<p>XSPF' solution: XSPF defers this functionality to
		  other sources.  Metadata is hard; there are already
		  many projects to deal with it, some of which are very
		  good.  Metadata is attached to an XSPF track according
		  to whatever syntax an imported vocabulary defines.
		  XML namespaces may be used, but the preferred syntax
		  is the XSPF <span class="elem">link</span> and <span
															class="elem">meta</span> elements.  (These elements
		  allows us to validate metadata from external sources,
		  while namespaces don't.)</p>
	  </dd><!-- first child of usecases -->

	  <dt><a name="Authoringcompilationsforexpressivereasons"/>Authoring compilations for expressive reasons</dt><!-- first child of usecases -->
	  <dd>
		<p>Scenario: A businessperson wants to make a batch of
		  videos of related talks from a conference because
		  watching them in a shared context gives a deeper
		  understanding of the subject as a whole.</p>

		<p>Typical solution: A user compiles copies of the
		  videos and puts them in the same location, maybe in
		  the same directory on a web server, maybe in the same
		  directory on a hard drive.  The user then puts the
		  locations, whether paths or URIs, into a file in the
		  M3U format.</p>

		<p>XSPF' solution: The XSPF <span
									   class="elem">trackList</span> element contains a
		  sequence of <span class="elem">track</span> elements,
		  each of which points to one of the objects.</p>
	  </dd><!-- first child of usecases -->

	</dl><!-- end usecases -->

<a name="Recipes"/><h2>Recipes</h2>

	<dl>

	  <dt><a name="HowdoIsetrelativepathsinanXSPFplaylistforexampleifIwanttouseitasafilemanifest"/>How do I set relative paths in an XSPF playlist, for example if I want to use it as a file manifest?</dt>
	  <dd><p>See the <a href="http://www.w3.org/TR/xmlbase/">XML Base</a> specification or <a href="http://www.w3.org/TR/xmlbase/#RFC2396">IETF RFC 2396</a>:</p>

		<blockquote>The rules for determining the base URI can be 
			summarized as follows (highest priority to lowest):
			<ol>
			  <li>The base URI is embedded in the document's content.</li>
			  <li>The base URI is that of the encapsulating entity (message, 
				document, or none).</li>
			  <li>The base URI is the URI used to retrieve the entity.</li>
			  <li>The base URI is defined by the context of the application.</li>
			</ol>
		</blockquote>
	  </dd>

	  <dt><a name="HowtoIconvertXSPFtoM3U"/>How to I convert XSPF to M3U?</dt>
	  <dd>Use the <a href="http://gonze.com/xspf/xspf2m3u.xsl">xspf2m3u.xsl</a> stylesheet.</dd>

	  <dt><a name="HowtoIconvertXSPFtoHTML"/>How to I convert XSPF to HTML?</dt>
	  <dd>Use the <a href="http://gonze.com/xspf/xspf2html.xsl">xspf2html.xsl</a> stylesheet.</dd>

	  <dt><a name="HowtoIconvertXSPFtoSMIL"/>How to I convert XSPF to SMIL?</dt>
	  <dd>Use the <a href="http://gonze.com/xspf/xspf2smil.xsl">xspf2smil.xsl</a> stylesheet.</dd>

	  <dt><a name="HowtoIconvertXSPFtoSoundblox"/>How to I convert XSPF to Soundblox?</dt>
	  <dd>Use the <a href="http://gonze.com/xspf/xspf2soundblox.xsl">xspf2soundblox.xsl</a> stylesheet.</dd>
	  <dt><a name="HowdoIcustomizeXSPFShouldIusenamespaces"/>How do I customize XSPF?  Should I use namespaces?</dt>
	  <dd>Use the meta or link elements.  Use meta if the element
		contains a single value, like "blue" or "rock"; use link if the
		element contents are a URL.  Try to avoid using namespaces to
		add fields, because namespaced items cannot be validated by an
		XSPF validator.</dd>

	  <dt><a name="HowdoIvalidateXSPF"/>How do I validate XSPF?</dt>
	  <dd><p>Robert Kaye has created a Relax NG schema for XSPF draft 8 at <a href="http://mayhem-chaos.net/stuff/xspf-draft8.rng">http://mayhem-chaos.net/stuff/xspf-draft8.rng</a>.  You can use <a href="http://www.thaiopensource.com/relaxng/jing.html">Jing</a> to invoke it.</p>
		<p>For users of Emacs nxml-mode, Ryan Shaw has posted a .rnc
		version of Robert's schema at <a
		href="http://lists.musicbrainz.org/pipermail/playlist/2004-October/000429.html">http://lists.musicbrainz.org/pipermail/playlist/2004-October/000429.html</a>.
		This is just a matter of putting the .rnc file in the schema/
		subdirectory of your nxml-mode installation.  nxml-mode will
		find it automatically and add it to the list of available
		schemas; if you begin authoring an XSPF playlist, nxml-mode
		will choose the correct schema by examining the root element
		name.</p>
	  </dd>

	  <dt><a name="HowdoIuseMusicBrainzmetadata"/>How do I use MusicBrainz metadata?</dt>
	  <dd>
		Rather than include the literal artist name, song duration, etc, for a track within a playlist, MusicBrainz gives the URL of an XML file containing these items.  Assume that the MusicBrainz definition of what a track listing means is at http://musicbrainz.org/track.  (There is nothing at that URL, which is fine -- the URL in an XSPF meta[@rel] attribute works the same way as the URL in an XML namespace declaration).   A typical track listing has a URL like http://musicbrainz.org/mm-2.1/track/bdc846e7-6c26-4193-82a6-8d1b5a4d3429.  
		<div class="example">
&lt;track&gt;
   &lt;identifier&gt;bdc846e7-6c26-4193-82a6-8d1b5a4d3429&lt;/identifier&gt;
   &lt;title&gt;Smoke Two Joints&lt;/title&gt;
   &lt;creator&gt;Sublime&lt;/creator&gt;
   &lt;duration&gt;175466&lt;/duration&gt;
   &lt;meta rel="http://musicbrainz.org/track"&gt;http://musicbrainz.org/mm-2.1/track/bdc846e7-6c26-4193-82a6-8d1b5a4d3429&lt;/meta&gt;
&lt;/track&gt;
		</div>

	  </dd>

	  <dt><a name="HowdoIrefertoaBitTorrent"/>How do I refer to a BitTorrent?</dt>
	  <dd>Put the torrent file in a playlist/trackList/track/location element.</dd>

	  <dt><a name="HowdoIrefertoaMagnetorsha1URI"/>How do I refer to a Magnet or sha1: URI?</dt>
	  <dd>A sha1: URI is a location independent canonical ID, so it
	  belongs in a playlist/trackList/track/identifier element.  A
	  Magnet URI is resolvable, so belongs in
	  playlist/trackList/track/location.</dd>	  

	</dl>

<a name="Administrative"/><h2>Administrative</h2>

	<dl>
	  <dt><a name="Validate"/>Validate</dt>
	  <dd>
		<ol>
		  <li><a href="http://validator.w3.org/check?uri=http%3A%2F%2Fgonze.com%2Fxspf%2Fxspf-draft-8.html">HTML</a></li>
		  <li><a href="http://jigsaw.w3.org/css-validator/validator?uri=http://gonze.com/xspf/xspf-draft-8.html">CSS</a></li>
		</ol>
	  </dd>
	</dl>

  </body>
</html>
