<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title>Hardware implementation of Theora decoding</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body><h1 align="center">Hardware implementation of Theora decoding</h1><h1 align="center">Integration with    LEON3</h1><p align="center">by student Andr&eacute; Luiz Nazareth da Costa (andre.lnc [at] gmail.com)</p><p align="center">and mentor Timothy B. Terriberry (tterribe [at] vt.edu)</p><p>&nbsp;</p><h2>About</h2><p>Decode a video in the Theora format requires a great power of processing.  In this way, the development of a specify hardware for it is a viable solution  and some modules had already been made successful in hardware on GSoC 2006  (Google Summer of Code). The idea is you get the FPGA with small embedded processor  and to put just the critical modules in the hardware.<br>  Goal of my project is to give continuity to the project of the last year, putting  one or more modules in hardware and then diminishing the cpu-time processing.  This implementation will be done in VHDL and synthesized to the Altera StratixII FPGA. GSoC Project page: <a href="http://code.google.com/soc/2007/xiph/appinfo.html?csaid=4235040C184DBD68">http://code.google.com/soc/2007/xiph/appinfo.html?csaid=4235040C184DBD68</a></p><h4>XIPH and Theora</h4><p>The Xiph.Org Foundation (<a href="http://www.xiph.org/">http://www.xiph.org/</a>) is a non-profit corporation dedicated to protecting the foundations of Internet multimedia from control by private interests. The purpose is to support and develop free, open protocols and software to serve the public, developer, and business markets.Theora is the video codec from Xiph, based on the VP3 codec donated by On2 Technologies.</p><h4>GSoC</h4><p>Google Summer of Code (<a href="http://code.google.com/soc/">http://code.google.com/soc/</a>) is a program that offers  student developers stipends to write code for various open source projects.  Google works with a several open source, free software and technology-related  groups to identify and fund several projects over a three month period. Historically,  the program has brought together over 1,000 students with over 100 open source  projects, to create hundreds of thousands of lines of code. The program, whichkicked off in 2005, is now (2007) in its third year.</p><h4>Hardware implementation</h4><p>The First step (analysis of theora decoding process) was studied firstly by  Felipe Portavales and after by Leonardo Piga. The conclusion was that the function  reconrefframes waste approximately 60% of CPU-time, but functions before have  a lot of struct's of decision and few struct's of processing (like multiplication).  You can see this on <a href="http://svn.xiph.org/trunk/theora-fpga/doc/">http://svn.xiph.org/trunk/theora-fpga/doc/</a>. Thus, thisfirst part isn't too interesting to be done in Hardware, but the reconrefframes is.</p><p>Felipe Portavales did the iDCT and Leonardo Piga did the others functions.  The VHDL simulation is OK and the synthesis in FPGA is OK too.</p><p>But, the integration was did with NIOS processor, which is a proprietary processor.  The alternative of a nonproprietary processor was the LEON.<br>  NIOS has a good interface and good support for FPGA. LEON has a different interface  and is very flexible. Then, I started to study more about this processor, my  first goal from GSoC was to do all the integration of Theora Hardware with  LEON. This page describe how to do this integration step by step. </p><h4>Sites:</h4><p>Theora: <a href="http://www.theora.org/">http://www.theora.org/</a></p><p>Xiph: <a href="http://www.xiph.org/">http://www.xiph.org/</a></p><p>Theora Hardware Wiki: <a href="http://wiki.xiph.org/index.php/TheoraHardware">http://wiki.xiph.org/index.php/TheoraHardware</a></p><p>Google Summer of Code page: code : <a href="http://code.google.com/soc/">http://code.google.com/soc/</a></p><p>GSoC Project page: <a href="http://code.google.com/soc/2007/xiph/appinfo.html?csaid=4235040C184DBD68">http://code.google.com/soc/2007/xiph/appinfo.html?csaid=4235040C184DBD68</a></p><p>Gaisler : <a href="http://www.gaisler.com">http://www.gaisler.com</a></p><p>Vorbis Hardware implementation on LEON2: <a href="http://oggonachip.sourceforge.net/">http://oggonachip.sourceforge.net/</a></p><p>MP3 Hardware implementation on LEON2: <a href="http://lampiao.lsc.ic.unicamp.br/~billo/leon2_on_mblazeboard/index.htm">http://lampiao.lsc.ic.unicamp.br/~billo/leon2_on_mblazeboard/index.htm</a></p><h4>Lists:</h4><p>Leon Sparc: <a href="http://tech.groups.yahoo.com/group/leon_sparc/">http://tech.groups.yahoo.com/group/leon_sparc/</a></p><p>Theora: <a href="http://lists.xiph.org/mailman/listinfo/theora-dev">http://lists.xiph.org/mailman/listinfo/theora-dev</a></p><h2>1 - The LEON3 processor.</h2><p align="center"><img src="leon3.JPG" width="746" height="393"></p><p align="center">figure 1</p><h4>About Gaisler</h4><p>Gaisler Research provides a complete framework for the development of processor-based  SOC designs. The framework is centered around the LEON processor core and includes  a large IP library, behavioral simulators, and related software development  tools.<br><a href="http://www.gaisler.com">http://www.gaisler.com</a></p><h4>About GRLIB</h4><p>The GRLIB IP Library is an integrated set of reusable IP cores, designed for  system-on-chip (SOC) development. The IP cores are centered around the common  on-chip bus, and use a coherent method for simulation and synthesis.<br><a href="http://gaisler.com/products/grlib/grlib.pdf">http://gaisler.com/products/grlib/grlib.pdf</a></p><h4>Choosing a ideal configuration (add my Configuration File)</h4><p>You need first to install the GRLIB (I worked with grlib-gpl-1.0.15-b2149.tar.gz  ), It is following the instructions on grlib.pdf<br>  After you have the GRLIB installed, you can run the &quot;make xconfig&quot; on &quot;grlib/designs/leon3-altera-ep2s60-sdr&quot; (I  used the Stratix II EP2S60F672C5ES).<br>There, you can select this components:</p><p>Component &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vendor<br>  LEON3 SPARC V8 Processor &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gaisler Research<br>  AHB Debug UART &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gaisler  Research<br>  AHB Debug JTAG TAP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gaisler  Research<br>  LEON2 Memory Controller &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;European  Space Agency<br>  AHB/APB Bridge &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gaisler  Research<br>  LEON3 Debug Support Unit &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gaisler  Research<br>  Generic APB UART &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GaislerResearch</p><p>My configuration file: <a href="config.in">config.in</a> </p><p>Now, you can run the synthesis of your design (make quartus).<br>  <em>FPGA problem pins:</em> You need pay attention in select the suitable design for    your FPGA, else you can have problem with pin mapping.<br></p><h4>Using the GRMON jTAG interface</h4><p>GRMON is a general debug monitor for the LEON processor, and for SOC designs  based on the GRLIB IP library.<br>  We will use this to Load and execution of LEON applications<br>Manual: <a href="http://www.gaisler.com/doc/grmon.pdf">http://www.gaisler.com/doc/grmon.pdf</a></p><p><a href="ftp://gaisler.com/gaisler.com/grmon/grmon-eval-1.1.21.tar.gz">ftp://gaisler.com/gaisler.com/grmon/grmon-eval-1.1.21.tar.gz</a></p><p>Run GRMON with this command:</p><p>grmon-eval -altjtag -u</p><p>-altjtag : Connect to the JTAG Debug Link using Altera USB Blaster or Byte  Blaster.<br>-u : Put UART 1 in loop-back mode, and print its output on monitor console.</p><p>&nbsp;</p><h2>2 - Application on LEON3</h2><p align="center"><img src="2_libt.png" width="688" height="419"></p><p align="center">figure 2</p><h4>libtheora-1.0alpha6, libogg-1.1.3 and sparc-elf-3.4.4-1.0.29</h4><p>Create a new path (like /theora_hardware/).<br>Do the download and  unpack the libtheora-1.0alpha6.tar.gz on /theora_hardware/</p><p><a href="http://downloads.xiph.org/releases/theora/libtheora-1.0alpha6.tar.gz">http://downloads.xiph.org/releases/theora/libtheora-1.0alpha6.tar.gz</a><br>  tar -xzf libtheora-1.0alpha6.tar.gz</p><p>Do the download and  unpack the libogg-1.1.3.tar.gz on /theora_hardware/libtheora-1.0alpha6/</p><p><a href="http://downloads.xiph.org/releases/ogg/libogg-1.1.3.tar.gz">http://downloads.xiph.org/releases/ogg/libogg-1.1.3.tar.gz</a><br>  tar -xzf libogg-1.1.3.tar.gz</p><p>Now, you will need to use the BCC (Bare-C Cross-Compiler). BCC is a cross-compiler  for LEON2 and LEON3 processors.<br>  Do the download and unpack the sparc-elf-3.4.4-1.0.29.tar.bz2 on /opt/</p><p>mkdir /opt<br>  tar -C /opt -xjf sparc-elf-3.4.4-1.0.29.tar.bz2</p><h4>dump_video.c modified and vector of input</h4><p>How we are not running on a Linux, you will need to take care with file functions.  You can to comment the fprint, to change the fread's to a vector of inputs  and the fwrite will be just a printf. Like this:</p><p><a href="dump_video_hardware.c">dump_video_hardware.c</a><br><a href="insert vector_of_input.h">insert vector_of_input.h</a></p><h4>BUG detected from OGG lib (unaligned address error).</h4><p>There was a error Bug from OGG lib:</p><p>IU in error mode (tt = 0x07)<br>  400013a4 e8220011 st %l4, [%o0 + %l1]</p><p>The trap type 0x07 is a memory access to unaligned address. Some architectures  support unaligned stores, but SPARC does not (just in 4 by 4 bytes). I had  a luck in to find a report from a group that put the Vorbis decoder on FPGA.  It was a master thesis of 2 students http://oggonachip.sourceforge.net/.</p><p>Then, you just need to type so extra lines in configure.in file (on Ogg library's,  /theora_hardware/libtheora- 1.0alpha6/libogg-1.1.3/) as follows:</p><p>AC_CHECK_SIZEOF(short,2)<br>  AC_CHECK_SIZEOF(int,4)<br>  AC_CHECK_SIZEOF(long,4)<br>  AC_CHECK_SIZEOF(long long,8)&quot;<br></p><h4>Compilation of Libtheora for LEON3 architecture </h4><p>You can run this script</p><p># Export sparc-elf PATH<br>  export PATH=/opt/sparc-elf-3.4.4/bin:$PATH</p><p># Clean all<br>  make distclean<br>  cd libogg-1.1.3/<br>  make distclean</p><p># Set CROSS-Compiler and parameters<br>  export CC=sparc-elf-gcc<br>  export CXX=sparc-elf-gcc<br>  export CFLAGS='-mv8 -msoft-float -static'<br>  # -mv-8 generate SPARC V8 mul/div instructions - needs hardware multiply and  divide<br>  # -msoft-float emulate floating-point - must be used if no FPU exists in the  system</p><p>#Configure and install OGG lib<br>  ./configure --prefix=/theora_hardware/ --target=sparc-elf    --host=sparc-elf --enable-static <br>  make<br>  make install</p><p>#Configure and make Theora for LEON (sparc)<br>  cd ../<br>  ./configure --prefix=/theora_hardware/ --target=sparc-elf  --host=sparc-elf --enable-static --disable-encode<br>  make</p><h4>How to do the test on figure 2</h4><p>After last step, you will have the binary &quot;dump_video_hardware&quot;.  At first step (The LEON processor) you generated by the synthesis a programmer  file(leon3mp.sof) that now you can to programmer your FPGA. Then, open the Grmon interface  and load the dump_video_hardware (&quot;load dump_video_hardware&quot;). Now, &quot;run  dump_video_hardware&quot;.</p><p>&nbsp;</p><h2>3 - LINUX on LEON3</h2><p>&nbsp;</p><p align="center"><img src="3_linux.png" width="688" height="357"></p><p align="center">figure 3</p><h4 align="left">Snapgear </h4><p align="left">LINUX support for LEON2 and LEON3 is provided through a special  version of the SnapGear Embedded Linux distribution. SnapGear Linux is a full  source package, containing kernel, libraries and application code for rapiddevelopment of embedded Linux systems.</p><p>Download the Snapgear:<br>  <a href="ftp://gaisler.com/gaisler.com/linux/snapgear/snapgear-p33a.tar.bz2">ftp://gaisler.com/gaisler.com/linux/snapgear/snapgear-p33a.tar.bz2</a></p><p>Snapgear Manual:<br>  <a href="ftp://gaisler.com/gaisler.com/linux/snapgear/snapgear-manual-1.33.0.pdf">ftp://gaisler.com/gaisler.com/linux/snapgear/snapgear-manual-1.33.0.pdf</a></p><p>Download the Sparc Linux Cross Compiler:<br>  <a href="ftp://gaisler.com/gaisler.com/linux/snapgear/sparc-linux-1.0.0.tar.bz2">ftp://gaisler.com/gaisler.com/linux/snapgear/sparc-linux-1.0.0.tar.bz2</a></p><p>Kernel versions that I am using: linux-2.6.21.1 for MMU system</p><p>The tool-chain should be installed under /opt :</p><p>cd /opt<br>  tar xjf /sparc-linux-1.0.0.tar.bz2</p><p>Add /opt/sparc-linux/bin to your PATH.</p><p>The SnapGear distribution can be installed anywhere:</p><p>tar -xjf snapgear-p33a.tar.bz2</p><p>General instructions on how to use SnapGear linux is provided with the distribution.</p><p align="left">&nbsp;</p><h4 align="left">Testing</h4><p>After programmer your FPGA with LEON3, you can open the GRMON with this command:<br>./grmon-eval -altjtag -nb -abaud 38400 -nosram</p><p>The GRMON should be started with -nb to avoid going into break mode on a page-fault  or data exception.</p><p><em>Problem with SRAM</em></p><p>I disabled the SRAM (-nosram) because I had just 2 Mbit of SRAM on my FPGA,  then I needed to load the kernel on SDRAM. But, I was having problems of memory  mapping. Thus, I decided disable the SRAM.<br>    <br>    <em>Serial and jTAG Dbg Link.</em></p><p>The &quot;-abaud 38400&quot; set application baudrate for UART 1.<br>  In order to have a konsole interface from linux you need to connect a serial    cable with you computer. Then, you can use a program like &quot;kermit&quot; that    provides a serial communication with your linux konsole on FPGA. Some FPGA&acute;s    has 2 serial connectors, BE SURE that you are using the suitable connector!.<br>  I am using the follow configuration of kermit:</p><p>set line /dev/ttyS0<br>  define sz !sz \%0 &gt; /dev/ttyS0 &lt; /dev/ttyS0<br>  set speed 38400<br>  set carrier-watch off<br>  set prefixing all<br>  set parity none<br>  set stop-bits 1<br>  set modem none<br>  set file type bin<br>  set file name lit<br>  set flow-control none<br>  set prompt &quot;Sparc Linux Kermit&gt; &quot;<br>  c</p><p><br>  Now, load your kernel image (image.dsu) generated with Snapgear and to see    your konsole running on kermit.</p><p>&nbsp;</p><h2>4 - Libtheora running on LINUX</h2><p align="center"><img src="4_linux_libt.png" width="688" height="419"></p><p align="center">figure 4</p><h4>Libtheora compilation for Linux on LEON3</h4><p>Now, you can use the original dump_video.c because you are using the linux.Then, you can to work with files. </p><p># Export sparc-linux PATH<br>export PATH=/opt/sparc-linux/bin/:$PATH</p><p># Clean all<br>  make distclean<br>  cd libogg-1.1.3/<br>  make distclean</p><p># Set CROSS-Compiler and parameters<br>  export CC=sparc-linux-gcc<br>  export CXX=sparc-linux-gcc<br>  export CFLAGS='-msoft-float -fPIC -static'<br>  # -msoft-float emulate floating-point - must be used if no FPU exists in the  system<br>  # -g generate debugging information - must be used for debugging with gdb<br>  # -fPIC generate position independent machine code. It is necessary because  we are using linux now.<br>  # -static when linking an application static, all code used from libraries  are included into the output binary</p><p>#Configure and install OGG lib<br>  ./configure --prefix=/homes_export/andre.lnc/theora/libtheora6_hard/ --target=sparc-linux    --host=sparc-linux --enable-static <br>  make<br>  make install</p><p>#Configure and make Theora for LEON (sparc)<br>  cd ../<br>  ./configure --prefix=/homes_export/andre.lnc/theora/libtheora6_hard/ --target=sparc-linux  --host=sparc-linux --enable-static<br>make</p><h4>How to do the test on figure 4</h4><p>After generate the binary for LINUX on LEON3, you need to do a copy of this  to /snapgear-p33/romfs/home/ and to make a image of linux kernel with the Theora  compiled (dump_video). Don`t forget to do a copy of some video to /snapgear-p33/romfs/home/.  Take care about size of your linux image, your SDRAM of FPGA needs to havespace for this.</p><p>Then:<br>  Programmer your board with LEON3;<br>  Load the linux image on LEON3 (using grmon);<br>  Open your kermit interface and set the configuration;<br>  Run the linux kernel (using grmon);<br>  Come back to kermit and you will see a konsole of Linux;<br>  Now, go to home (cd home) and run the dump_video (./dump_video video.ogg);</p><h4>&nbsp;</h4><h2>5 - A Peripheral on LEON3</h2><p align="center"><img src="5_apb_hardware.png" width="600" height="373"></p><p align="center">figure 5</p><h4>AHB and APB bus</h4><p>AHB is a new generation of AMBA bus which is intended to address the requirementsof high-performance synthesizable designs. It is a high-performance system bus thatsupports multiple bus masters and provides high-bandwidth operation.<br>AMBA AHB implements the features required for high-performance, high clockfrequency systems.<br>The APB is part of the AMBA hierarchy of buses and is optimized for minimal powerconsumption and reduced interface complexity.The AMBA APB appears as a local secondary bus that is encapsulated as a single AHBslave device. APB provides a low-power extension to the system bus whichbuilds on AHB signals directly.<br>The APB bridge appears as a slave module which handles the bus handshake andcontrol signal retiming on behalf of the local peripheral bus.</p><h4>AMBA Protocol</h4><p>You can see details:<br><a href="http://www.gaisler.com/doc/amba.pdf">http://www.gaisler.com/doc/amba.pdf</a></p><h4>Why APB interface was choosed.</h4><p>I was searching on  teses and articles in order to decide where would be the best place for Theora    Hardware and how I could to do the communication between software and hardware    by bus and to pass the data's for hardware. I found many differents solution.<br>  The AHB is a high speed bus suitable to connect units with high data rate.  But, the problem is that the Theora Hardware will be a Master on AHB bus and  could overload the bus and diminish the performance of LEON3. APB is slower  than AHB. However the protocol is simpler than AHB and don't disturb the communication  between LEON3 and Memory controller. Also, I found hybrids solution with APBand AHB, but I thought better to plug this just on APB bus.</p><p>&nbsp;</p><h2>6 - Plugging Theora Hardware on LEON3</h2><p align="center"><img src="6_input_vector.png" width="707" height="457"></p><p align="center">figure 6</p><h4>How to include a APB core </h4><p>How to include the Theora APB core</p><p>Create the path grlib/lib/opencores/theora_hardware<br>  Include &uml;theora_hardware&uml; on grlib/lib/opencores/dir.txt</p><p>Download the revision 13432 from SVN on grlib/lib/opencores/theora_hardware/:<br>  <a href="http://svn.xiph.org/trunk/theora-fpga/">http://svn.xiph.org/trunk/theora-fpga/</a>  </p><p>You will need to change the name of entity syncram to tsyncram of the modules:  Syncram, expand block, loopfilter, copyrecon, databuffer. It is because syncram  is a name used in other different component from LEON3.</p><p>Now, we need to create the theora_hardware.vhd and theora_amba_interface.vhd:<br>  <a href="theora_hardware.vhd">theora_hardware.vhd</a> and <a href="theora_amba_interface.vhd">theora_amba_interface.vhd</a></p><p>Create vhdlsyn.txt on grlib/lib/opencores/theora_hardware/vhdlsyn.txt and  include all the vhdl`s</p>  <p>  If you prefer, you can download these files here: <a href="theora_hardware1.tar">theora_hardware1.tar</a> </p><p>You should include the Theora Hardware APB/AMBA (OPENCORES_THEORA_HARDWARE  on VENDOR_OPENCORES) just changing the file devices.vhd (grlib/lib/grlib/amba/):<br>  <a href="devices.vhd">devices.vhd</a></p><p>Finally, we need instantiate the theora_hardware on leon3.vhd and take care  about to use a selector free of APB slave output vector (apbo(i)):<br>  <a href="leon3mp_2.vhd">leon3mp.vhd</a><br>  <br>  Before synthesis (&quot;make quartus&quot;), Type the commands &quot;make distclean&quot; and &quot;make  script&quot; on your path (design grlib/designs/leon3-altera-ep2s60-sdr/).<br></p><h4>Addressing protocol that I did between Software Interface and Theora_amba_interface</h4><p>struct theora_regs_t {<br>  volatile int flag_send_data; <br>  volatile int data_transmitted;<br>  volatile int flag_read_data;  <br>  volatile int data_received;   <br>};<br><br>struct theora_regs_t  * theora_regs = (struct theora_regs_t  *)0x80000800;<br><br>flag_send_data (address 0x80000800): It is a flag used to the driver to know if can send a data to Theora Hardware. <br>data_transmitted (address 0x80000804): Data Transmitted to Theora Hardware<br>flag_read_data (address 0x80000808): It is a flag used to the driver to know Can the driver receive a data from Theora Hardware.<br>data_received (address 0x8000080C): Data received from Theora Hardware<br><br></p><h4>How to do a Software interface</h4>If you can send a data, you need to do a loop on software until the flag_send_data to be '1'. Then you can send by data_transmitted.<br>If you can write a data, you need to do a loop on software until the flag_read_data to be '1'. Then you can send by data_received.<br>Below is a example of a simple software that I did to test this comunication:<br><br><a href="send_vector_of_input.c">send_vector_of_input.c</a> and <a href="input.h">input.h</a><br>Compiling the software:<p> sparc-elf-gcc -mv8 -msoft-float -g send_vector_of_input.c -o send_vector_of_input.exe<br></p>       <h4>Inputs and ReconRefFrames</h4>There is a correct sequence of inputs that you need to send to ReconRefFrames. You can generate this vector of inputs with a libtheora modified:<br><a href="libtheora-1.0alpha6-fpga.tar.gz">libtheora-1.0alpha6-fpga.tar.gz</a><h4>Theora AMBA interface</h4><p>The <a href="theora_amba_interface.vhd">Theora_amba_interface</a> implement the APB/AMBA peripheral in order to receive and transmit the data's from driver to Theora_hardware using the Addressing protocol defined above and the ReconReframe protocol. </p><h2>7 - Integration Software and Hardware of Theora decoder on LEON3</h2><p align="center"><img src="7_linux_libt_hardware.png" width="702" height="545"></p><p align="center">figure 7</p><h4>Driver Theora</h4><p>A driver is necessary because we are using a linux. Then, a software running on linux can not write in a real address, it needs of a driver. <br>There are many tutorial on internet of how to do a character device, then I will not talk about these details.The parameters of transaction between software and driver that I did are these:<br><br>struct _data<br>{<br>    int read;<br>    int wrote;<br>    int data;<br>};<br>struct _data dt;<br><br>I/O control function: theora_ioctl(struct inode *inode, struct file *filp, unsigned int nFunc,  unsigned long nParam)<br><br>If nFunc = '0' means that the driver will try to do a reading on Theora Hardware. If nFunc = '1', the driver will try to do a writting on Theora Hardware.<br><br>If occurred a successful reading, the dt.read will return 1. If not, will return 0.<br>If occurred a successful writting, the dt.wrote will return 1 and the data on dt.data. If not, the dt.wrote will return 0.<br><br>See the driver theora: <a href="theora.c">theora.c</a><br><br><h4>How to include the driver on linux image</h4><p>Include the theora.c (the driver) on snapgear-p33/linux-2.6.21.1/drivers/char/ <br><br>Include the line "obj-$(CONFIG_THEORA) += theora.o" on snapgear-p33/linux-2.6.21.1/drivers/char/Makefile. Like this <a href="Makefile_char">Makefile</a><br><br>Include the lines ...<br>config THEORA<br>	bool "Theora Driver"<br>	default y <br><br>... on snapgear-p33/linux-2.6.21.1/drivers/char/Kconfig. Like this <a href="Kconfig">Kconfig</a><br><br>You need to make sure to select a unique number from the  snapgear-p33/linux-2.6.21.1/Documentation/devices.txt. In my case was the number 121.<br>Then, you need to add the line "DEVICES = theora,c,121,0 \" on snapgear-p33/vendors/gaisler/leon3mmu/Makefile. Like this <a href="Makefile_leon">Makefile</a>. It will create a /dev/mydriver each time make is run.<br><br>Now, if you want generate the linux image, you just need to do a "make" on snapgear-p33 path<br><br>When you boot the linux from FPGA you will see these lines:<br>Loading theora ...<br>LEON THEORA driver by Andre Costa (2007) - andre.lnc@gmail.com<br><br></p><h4>Problems:</h4>Below I will describe some errors that I had with the driver and how to solve it:<p>- Unable to handle kernel paging request at virtual address 80000000:<br>The MMU protects certain memory spaces, you either bypass the MMU usingthe SPARC specific STA or LDA instructions (not recommended) or useioremap to inform the MMU about the new area. In my case I used the ioremap.</p><p>- Warning: ioremap: done with statics, switching to malloc<br>Error (running on FPGA): alloc_io_res(phys_80000800): cannot occupy<br> Halt<br>Halt<br><br>The problem is that you repeatedly call ioremap(). Youshould do this once and keep the pointer returned from ioremap and usethis to access the hardware in the rest of the code. I was using the ioremap on ioclt(), but It should be on theora_init().</p><p>- BUG: soft lockup detected on CPU#0! <br>Soft lockup is when the kernel fails to reschedule for 10 seconds. Thisimplies that your driver does not yield the CPU. For example, in yourread/write functions you should either return immediately or sleep untilwoken up by an interrupt. You may not busy wait. I was doing the loop (until receive a data from theora_hardware) on driver, but It should do just on modified libtheora software.</p><h4>How to cut LIBTHEORA and to send the data's to Driver Theora</h4><p>You will to edit the dct_decode.c from libtheora. First, open the driver: pf = open("/dev/theora",O_RDONLY|O_WRONLY|O_TRUNC|O_CREAT);The function write_theoradriver(int pf, int data) that was implemented is responsable to send a data to the driver. Then, we need to send all the data's and receive in a correct sequence. Take care about this, if just a data was not sent or read it's can stop all the pipeline of decodification. You can receive back the data in order to compare the output.<br><a href="dct_decode2.c">dct_decode2.c</a> <br><a href="codec_internal.h">codec_internal.h</a> (some little changes on this file)<br></p><h2>8 - Video Controller</h2><p align="center"><img src="8_video_controller.png"></p><p align="center">figure 8</p><p>The controller consists of a YUV to RGB converter and a video signal generator that send the signal to a D/A converter.</p><h4>Lancelot board</h4><p align="center"><a href="http://www.microtronix.com/products/?product_id=97"><img src="lancelot.jpg"></a></p><p>It is a video D/A converter and It is necessary because the Stratix II doesn't have one.<br>You should read the <a href="http://www.microtronix.com/_dat/products/files/97/lancelotusermanual.pdf">Manual</a></p><h2>9 - Integration Video Controller and Hardware Theora</h2><p align="center"><img src="9_integration_video.png"></p><p align="center">figure 9</p><p>Leonardo Piga did a video controller and he plugged it on NIOS. Then I worked in order to pluged this video controller on my LEON-Theora integration and I found some problems that I will describe.</p><h4>Changes</h4><p><i>dct_decode:</i> The differences between this dct_decode.c and dct_decode2.c is that now we don't need to receive the outputs of reconrefframe and compare with software, we just need to send the data's predecoded to reconrefframe.Beyond this, we need to send the height and the width, because the videocontroller will request.<br>  You can see my dct_decode: <a href="dct_decode.c">dct_decode.c</a> and <a href="dump_video.c">dump_video.c</a> (Now we can't see print to any file, the data's are transmitted to theora_amba_interface)<br></p><p><i>Hierarchy of the modules:</i> Now we have the theora_hardware that will have the reconrefframe and the video controller. It was necessary to do some adaptations (theora_apb.vhd, theora_amba_interface.vhd, theora_hardware.vhd ...). Here you can download all these modules: <a href="theora_apb.tar">theora_apb.tar</a></p><p><i>Pins of Lancelot: </i> You will need to connect all pins of lancelot on to leon system. My new leon3mp is <a href="leon3mp.vhd">leon3mp.vhd</a>, and my file of connections: <a href="leon3mp.qsf">leon3mp.qsf</a></p><p></p><h4>Memory Problems</h4>At first time, this system (LEON+ Theora_Hardware + Video Controller) was using a lot of internal memory, I was not getting to join it on my FPGA. There was some bugs on video controller and that size of buffer was not necessary, but if changed the size (to a video of 96x80), it was not running. These bugs are solved, but I just decode a video of 96x80 resolution. It will be futurely solved when the external memory is implemented.<p></p><h4>Cross-clock domain</h4><p>I had some difficult in to plug it on Leon, because of hardware constrains. The clock frequency used by video controller is of 25 MHz, but the frequency of Leon system is of 50 MHz. It was not just to put a simples clock divider, because on the synthesis a had problems of cross-clock domain at time analysis. The video controller (25 MHz) need to receive data's from a module of 50 MHz.  It was generating a clock skew problems. The solution was simples, I needed to change some parameters on PLL of Leon system, the PLL (phase-locked loop) is basically a closed loop frequency control system that generate the clocks of Leon and sdram with the phase adjusted, I needed to include a new clock there with the correct parameters. Like this on /grlib/lib/techmap/clocks/clkgen_altera_mf.vhd <br><a href="clkgen_altera_mf.vhd">clkgen_altera_mf.vhd</a></p><h4>A band of 8 pixel green below of video</h4><p>The dump_video includes a band of 8 pixel green below of video. If run a video of 96x72, I will have a video of 96x80. Something like:<br>Ogg logical stream 583c6ca0 is Theora 96x80 29.97 fps video<br>Encoded frame content is 96x72 with 0x0 offset<br><br>Theora encodes the frame in whole 16x16 macro blocks, so both the widthand height must be a multiple of 16. When the actual video content isnot a multiple of 16, it is expanded to one and a clipping rectangle isstored in the header (that's the "Encoded frame content..." message).dump_video does not crop the output down to the actual size of thisrectangle, but outputs the entire expanded frame. The encoder by defaultstores zeros in this part of the frame, so that's why it looks green.</p>
<h4>Littles purple points on video</h4>
<p>
At first tests, there were littles purple points on the image, It needed of a shift phase on video controller clock (25 MHz). We think that the reading of video controller memory was happening at the same phase of writting.
</p>

<h4>ffmpeg2theora</h4><p><a href="http://ffmpeg.mplayerhq.hu/">Here</a> you can find the ffmpeg2theora software that you can change the resolution, the start and end point, and more some things very usefull that you certainly will need to do to tests some videos.</p>


<h4>Demostration</h4><p> I did a demonstration of this integration until the video controller and it is on youtube. <a href="http://www.youtube.com/watch?v=tZSsz1b28rA">Click here to see the video</a><br><center><object width="425" height="350"> <param name="movie" value="http://www.youtube.com/v/tZSsz1b28rA"> </param> <embed src=" http://www.youtube.com/v/tZSsz1b28rA" type="application/x-shockwave-flash" width="425" height="350"> </embed> </object></center></p>This video shows the sequence:<br><br>- Programmer the board (Stratix II)with LEON3 (by USB Blaster - jtag);<br><br>- Load the linux image on LEON3 (using grmon, by USB Blaster - jtag). The Unknown device is the Theora Hardware, it is not show the name "Theora Hardware" because I am using a evaluation version of Grmon;<br><br>- Open the kermit interface and set the configuration (by Serial Interface);<br><br>- Run the linux kernel (using grmon, by USB Blaster - jtag);<br><br>- Come back to kermit and you will see a konsole of Linux (by Serial Interface). Here you can the "LEON Theora Driver" that is recognize by the linux;<br><br>-Now, I go to home path and run the dump_video (./dump_video ronaldinho9680.ogg);<br><p>My current FPGA programmer file: <a href="leon3mp.sof">leon3mp.sof</a><br>My current LINUX Kernel images (with theora driver and dump_video included and complied): <a href="image.dsu">image.dsu</a><br></p><p>
The size is little because the buffer multiplexed with a external memory (SRAM) was not implemented, then we just have to user the few blocks of internal memory of FPGA.<br>
There are basically one problem in this presentation. On NIOS, a video was running very slow, almost 7 times. On my LEON system it is still slow, but just 5 times, then the perfomance is a little better then NIOS. A video of 15 second is taking 75 seconds (5 times). 
</p>
<p>
I discovered that the problem was on LINUX! If I don't use the linux (like is done on NIOS), I can to decode much faster than the time of exibition!<br>
The problem is the LINUX Call systems, because I am calling the driver for each word that I want to send. The solution would be to do a copy from a block of words to the driver, but it isn't implemented for while.
<br>
Without the LINUX, a video (30 seconds) encoded with the best quality (ffmpeg2theora -x 96 -y 80 -v 10 -e 30 original.ogg -o video.ogg) is decoded in 25 seconds. Below I will discribe this other implementation.
</p>

<p>&nbsp;</p><h2>10 - LEON3 and Hardware Theora without LINUX</h2>
<p align="center"><img src="12_theora.png"></p>

<br><br><h4>Demostration</h4>
<br>
Now we have two points on software (the hardware is the same, LEON+Theora_hardware):
<br><br>
[a] Theora on LINUX: Here we have a .ogg file that can be decoded on FPGA and shown on a monitor. But it can't be decoded in time of exibition. I suppose that the problem is the LINUX system call, but I don't have any idea how it could be solved.
<br><br>
[b] Theora without LINUX: Here, we can to decode much faster that the time of exibition. But, without LINUX, we can't to use a .ogg file directly, we need to convert it in a vector and to compile with dump_video (the Leonardo also needs to do it on NIOS).
<center>
<object width="425" height="350"> <param name="movie" value="http://www.youtube.com/v/NBLF6L5akJo"> </param> <embed src="http://www.youtube.com/v/NBLF6L5akJo" type="application/x-shockwave-flash" width="425" height="350"> </embed> </object>
</center>
<br><br>
The most important is that now we have a complete theora decoding on FPGA and with no NIOS or any module proprietary. Putting a ogg video a seeing a video on monitor.
<br>
<br>
We are working with a 96x80 of resolution, that video (on youtube) was duplicating the output pixels. 
The next step will be to do plug it (the system [b]) on the SRAM memory in order to increase the resolution.
<br><br>
You can to do the download of the last version of theora hardware and the integration at svn:
<a href="https://trac.xiph.org/browser/trunk/theora-fpga">https://trac.xiph.org/browser/trunk/theora-fpga</a>         

  </p>
<p>&nbsp;</p><h2>11 - Memory Controller for our Memory Muliplexed</h2><p align="center"><img src="10_memory_controller.png" width="423" height="168"></p><p align="center">figure 10</p><p>NOT IMPLEMENTED</p>
<p>&nbsp;</p><h2>12 - Full Integration</h2><p align="center"><img src="11_integration_full.png"></p><p align="center">figure 11</p><p>&nbsp;</p><h4>Final consideration</h4><p>[to complete]</p><h4>Timing analysis </h4><p>[to complete]</p><p>&nbsp;</p>

<script language="JavaScript">
<!--
  // Hit counter code for Webstat.net
  var data = '&r=' + escape(document.referrer)
	+ '&n=' + escape(navigator.userAgent)
	+ '&p=' + escape(navigator.userAgent)
	+ '&g=' + escape(document.location.href);
  if (navigator.userAgent.substring(0,1)>'3')
    data = data + '&sd=' + screen.colorDepth 
	+ '&sw=' + escape(screen.width+'x'+screen.height);
  document.write('<img alt="Free Counter" width="0" height="0" border="0" hspace="0" '+'vspace="0" src="http://www.webstat.net/basic/counter.php?i=85968' + data + '">');
// -->
</script>
<center>
<a href="http://www.webstat.net/" target="_blank"><img alt="Free Counter" border="0" hspace="0" vspace="0" src="http://www.webstat.net/basic/track/85968.png"></a>                           

</center>
</body></html>