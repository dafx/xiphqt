# -*-Perl-*-
use Tk;
package MGMmodule::cpustat;

sub module_run{
    my($this)=@_;
    $this->{"graph"}=MGM::Graph->new($this,num=>$this->{"statcpus"},fixed=>'1',
			   prompt=>"%",rangecurrent=>100,rangesetting=>'100');
    $this->{"graph"}{"widget"};        # must return widget
}

sub module_update{ 
    my$this=shift;
    
    # in late 2.1+ kernels, each CPU has an entry in /proc/stat along with
    # a common entry.  Earlier, only the common entry.
    
    my($load,$total,$statcpus)=$this->read_proc;
    my$prevload=$this->{"prevload"};
    my$prevtotal=$this->{"prevtotal"};
    
    if(defined($prevload)){
	my@vals;
	
	if($this->{"statcpus"}==1){
	    my$tot=$total->[0]-$prevtotal->[0];
	    if($tot>0){
		$vals[0]=100*($load->[0]-$prevload->[0])/$tot;
		$vals[0]=100 if $vals[0]>100;
	    }else{
		$vals[0]=0;
	    }
	}else{
	    for(my$i=0;$i<$this->{"numcpus"};$i++){
		my$use=$i+1;
		my$tot=$total->[$use]-$prevtotal->[$use];
		if($tot>0){
		    $vals[$i]=100*($load->[$use]-$prevload->[$use])/$tot;
		    $vals[$i]=100 if $vals[$i]>100;
		}else{
		    $vals[$i]=0;
		}
	    }
	}
	$this->{"graph"}->set(@vals);
    }
    
    @{$this->{"prevload"}}=@{$load};
    @{$this->{"prevtotal"}}=@{$total};
    
}
    
sub module_instance{
    my$this=shift;
    my$toplevel=$this->{"toplevel"};
    my$xpath=$this->{"xpath"};
    my$statcpus=$this->{"statcpus"};
    my$numcpus=$this->{"statcpus"};

    ($minx,$miny)=MGM::Graph::calcxysize($this,100,'%',$statcpus);

    if($numcpus>1 && $statcpus==1){
	$toplevel->optionAdd("$xpath.bar.0.label", "cpus 0-".($numcpus-1),22);
    }else{
	for(my$i=0;$i<$numcpus;$i++){
	    $toplevel->optionAdd("$xpath.bar.$i.label", "cpu$i",22);
	}
    }

    $toplevel->optionAdd("$xpath.scalewidadj", 100*$statcpus,21);
    $toplevel->optionAdd("$xpath.scalelenadj", 100,21); 

    $toplevel->optionAdd("$xpath.minx",     $minx,21);      
    $toplevel->optionAdd("$xpath.miny",     $miny,21);      

    $this;
}

sub module_init{
    my$this=shift;

    # how many CPUs? Get this from /proc/cpuinfo then /proc/stat.
    # /proc/stat only sees multiple CPUs as of late 2.1, but we
    # at least want to mark the single bar as SMP under 2.0

    my$numcpus=0;
    die "Couldn't open /proc/cpuinfo\n" unless open(PROC,"</proc/cpuinfo");
    while(<PROC>){
	if(m/processor\s*:\s*(\d*)/){
	    $numcpus=$1+1 if ($numcpus<$1+1);
	}
    }
    close PROC;
    $this->{"numcpus"}=$numcpus;

    # now run one 'update' to intialize things and see what CPUs pop up there.
    (undef,undef,$this->{"statcpus"})=$this->read_proc;
    if(!$this->{"statcpus"}){
	$this->{"toplevel"}->optionAdd($this->{"xclass"}.".active",0,21);
    }
    $this->{"toplevel"}->optionAdd($this->{"xclass"}.".order",     1,21);      
    $this;
}

sub read_proc{
    shift;
    my @load;
    my @total;
    my $statcpus=1;
    if(open(PROC,"</proc/stat")){
	while(<PROC>){
	    if(m/^cpu(\d*)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/){
		if(length($1)){
		    # per-cpu entry
		    $load[$1+1]=$2+$3+$4;
		    $total[$1+1]=$2+$3+$4+$5;
		    $statcpus=$1+1 if($1+1>$statcpus);
		}else{
		    # the common entry 
		    $load[0]=$2+$3+$4;
		    $total[0]=$2+$3+$4+$5;
		}
	    }
	}
	close PROC;    
	(\@load,\@total,$statcpus);
    }else{
	(undef,undef,0);
    }
}

bless {};

