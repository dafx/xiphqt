# -*-Perl-*-

# instances allowed: one 

# (single instance modules would be silly to use more than one of
# anyway, so we use package local storage.  This is faster and places
# less artificial load on the machine than doing everything through
# the object hash)

package MGMmodule::battery;
use vars qw($state $graph $widget $xpath);

sub module_init{
    my$this=shift;
    my$xclass=$this->{"xclass"};
    my$toplevel=$this->{"toplevel"};


    my$test=$this->read_proc;
    if(!defined($test)){
	$toplevel->optionAdd("$xclass.active",        'false',21);      
    }
    $toplevel->optionAdd("$xclass.order",201,21);      
    $this;
}

sub module_instance{
    my$this=shift;
    my$toplevel=$this->{"toplevel"};
    return undef if(defined($xpath));
    $xpath=$this->{"xpath"};

    # modify defaults
    $toplevel->optionAdd("$xpath.order",201,21); # status group
    $toplevel->optionAdd("$xpath.scalerefresh",10000,21); # 10s
    $toplevel->optionAdd("$xpath.scalereturn" ,1,21);     # don't need hyst
    $toplevel->optionAdd("$xpath*label", "battery",21);
    $toplevel->optionAdd("$xpath*lowlabel", "battery low",21);
    $toplevel->optionAdd("$xpath.scalewidadj", 80,21);  # narrower
    $toplevel->optionAdd("$xpath.scalelenadj", 100,21);

    my$fg=&main::moption($this,"litforeground");
    $toplevel->optionAdd("$xpath*midforeground", $fg,21);
    $toplevel->optionAdd("$xpath*litbackground", '#60c060',21);
    $toplevel->optionAdd("$xpath*midbackground", '#d0d060',21);
    $toplevel->optionAdd("$xpath*lowbackground", '#ff4040',21);
    $toplevel->optionAdd("$xpath*lowforeground", '#ffffff',21);

    my($minx,$miny)=&MGM::Graph::calcxysize($this,100,'%',1);
    $toplevel->optionAdd("$xpath.minx",        $minx,21);      
    $toplevel->optionAdd("$xpath.miny",        $miny,21);      
    $this;
}

sub module_run{
    my$this=shift;
    
    $graph=MGM::Graph->new($this,num=>1,fixed=>1,rangesetting=>100,
			   rangecurrent=>100,
			   prompt=>'%');

    # color change hack
    $state=0;
    $this->module_update;
    $graph->{"widget"};        # must return the widget
}

sub read_proc{
    my$this=shift;
    my$percent;
    if(open(PROC,"/proc/apm")){
	sysread PROC,$_,1024;
	if(m/^\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+([^ \%]+)\%/){
	    $percent=$1;
	}
	close PROC;
    }
    $percent;
}

sub module_update{ 
    my$this=shift;
    my$toplevel=$this->{"toplevel"};
    
    my$percent=$this->read_proc;
    if(defined($percent)){
	# apm, for some reason, seems to occasionally return -1/1.
	# guard against that
	if($percent<=1){
	    $percent=$this->read_proc;
	}

	if($percent>=0){
	    $graph->set($percent);
	    if($percent<30){
		# below 30%, it would be nice to unfix the scale so 
		#the  user can see		
		if($percent<8){
		    if($state!=2){
			$graph->
			    barconfigure(0,'aforeXr'=>'lowforeground',
					 'abackXr'=>'lowbackground',
					 'labelXr'=>'lowlabel');
			$graph->configure(fixed=>0,rangesetting=>8);
			$state=2;
		    }
		}else{
		    if($state!=1){
			$graph->
			    barconfigure(0,'aforeXr'=>'midforeground',
					 'abackXr'=>'midbackground',
					 'labelXr'=>'label');
			$graph->configure(fixed=>0,rangesetting=>32);
			$state=1;
		    }
		}
	    }else{
		if($state!=0){
		    $graph->
			barconfigure(0,'aforeXr'=>'litforeground',
				     'abackXr'=>'litbackground',
					     'labelXr'=>'label');
		    $graph->configure(fixed=>1,rangesetting=>100);
		    $state=0;
		}
	    }
	}
    }
}

sub destroy{
    undef $xpath;
}

bless {};

