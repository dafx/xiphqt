# -*-Perl-*-

# this module is a hack; it isn't a widget builder.  It sits in the
# background and reads /proc/stat, /proc/net/dev and
# /proc/net/wireless for other modules to reduce opens/closes.

# It defines an init method that installs the /proc/stat listener,
# then marks itself 'inactive' so that mgm doesn't try to call _run,
# _update or allocate space.  The last part of the hack is the name
# beginning with 00 so that it loads before the other modules that
# depend on it


package MGMmodule::helperST;
use vars qw(%proc %net %wi $lastmod $active $active_if $wi_count $wi_active);
use IO::Seekable;

sub module_init{
    my$this=shift;
    my$xclass=$this->{"xclass"};
    my$toplevel=$this->{"toplevel"};
    my$widget=$this->{"widget"};
    
    $toplevel->optionAdd("$xclass.scalerefresh",500,21); # keep up with cpustat
    my$refresh=$widget->optionGet("scalerefresh","");
    
    $lastmod=0;
    $active=0;
    $wi_active=0;
    if(open(PROC,"/proc/stat")){
	if(open(WI,"/proc/net/wireless")){
	    $wi_active=1;
	}
	if(open(NET,"/proc/net/dev")){
	    $active=1;
	    $this->module_update;
	    $toplevel->repeat($refresh,\&module_update)if(defined(%proc));
	}
    }
    $toplevel->optionAdd("$xclass.active",0,21);
    $this;
}

sub module_instance{
    shift;
}

sub module_update{
    my$data;
    my$netd;
    my$wid;
    sysseek PROC, 0, SEEK_SET;
    sysseek NET, 0, SEEK_SET;
    sysread NET,$netd,1024;
    sysread PROC,$data,4096;
    if($wi_active){
	sysseek WI, 0, SEEK_SET;
	sysread WI,$wid,4096;
	$wi_count=0;
	undef %wi;
	map{
	    my$pos=rindex $_, ":";
	    if($pos>0){
		my$key=substr $_,0,$pos;
		$key=~s/^\s*(\S+)\s*/$1/;
		$wi{$key}=substr $_, $pos+1;
		$wi_count++;
	    }
	} split "\n", $wid;
    }
	
    $active_if=0;
    undef%net;
    map{
	my$pos=rindex $_, ":";
	if($pos>0){
	    my$key=substr $_,0,$pos;
	    $key=~s/^\s*(\S+)\s*/$1/;
	    $net{$key}=substr $_, $pos+1;
	    $active_if++;
	}
    } split "\n", $netd;

    map{
	m/^(\S+)\s+(.*)/;
	$proc{$1}=$2;
    } split "\n", $data;

    # what a great hack
    $proc{"cpu"}=~m/(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/;
    $lastmod=$1+$2+$3+$4; # 100ths of a second, even with 'broken' 2.0 SMP proc
}

bless {};


